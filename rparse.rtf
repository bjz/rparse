{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green72\blue255;\red104\green0\blue254;\red161\green33\blue108;
\red140\green83\blue65;\red219\green255\blue255;}
\deftab480
\pard\pardeftab480\pardirnatural

\f0\b\fs48 \cf0 char parsers
\fs36 \

\fs28 \cf2 fn
\b0 \cf0  
\b match
\b0 (
\i \cf2 predicate:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (\cf3 char\cf0 ) -> \cf3 bool\cf0 , 
\i \cf2 err_mesg:
\i0 \cf0  \cf3 str\cf0 ) -> parser<\cf3 char\cf0 >\

\i \cf4 Consumes a character which must satisfy the predicate
\f1\fs24 \cf0 .
\i0 \
\

\f0\b\fs48 str parsers
\fs36 \

\fs28 \cf2 fn
\b0 \cf0  
\b liti
\b0 (
\i \cf2 s:
\i0 \cf0  \cf3 str\cf0 ) -> parser<\cf3 str\cf0 >\

\i \cf4 Returns s if input matches s ignoring case.
\f1\i0\fs24 \cf0 \

\f0\fs28 \

\b \cf2 fn
\b0 \cf0  
\b lit
\b0 (
\i \cf2 s:
\i0 \cf0  \cf3 str\cf0 ) -> parser<\cf3 str\cf0 >\

\i \cf4 Returns s if input matches s.
\f1\i0\fs24 \cf0 \
\

\f0\b\fs28 \cf2 fn
\b0 \cf0  
\b match0
\b0 (
\i \cf2 predicate:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (\cf3 char\cf0 ) -> \cf3 bool\cf0 ) -> parser<\cf3 str\cf0 >\

\i \cf4 Consumes zero or more characters matching the predicate.
\f1\i0\fs24 \cf0 \

\f0\fs28 \

\b \cf2 fn
\b0 \cf0  
\b match1
\b0 (
\i \cf2 predicate:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (\cf3 char\cf0 ) -> \cf3 bool\cf0 , 
\i \cf2 err_mesg:
\i0 \cf0  \cf3 str\cf0 ) -> parser<\cf3 str\cf0 >\

\i \cf4 Consumes one or more characters matching the predicate.
\f1\i0\fs24 \cf0 \
\

\f0\b\fs28 \cf2 fn
\b0 \cf0  
\b scan0
\b0 (
\i \cf2 fun:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ ([\cf3 char\cf0 ], \cf3 uint\cf0 ) -> \cf3 uint\cf0 ) -> parser<\cf3 str\cf0 >\

\i \cf4 Calls fun with an index into the characters to be parsed until it returns zero characters.
\f1\i0\fs24 \cf0 \

\f0\i\fs28 \cf4 Increments line.
\f1\i0\fs24 \cf0 \

\f0\fs28 \

\b \cf2 fn
\b0 \cf0  
\b scan1
\b0 (
\i \cf2 err_mesg:
\i0 \cf0  \cf3 str\cf0 , 
\i \cf2 fun:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ ([\cf3 char\cf0 ], \cf3 uint\cf0 ) -> \cf3 uint\cf0 ) -> parser<\cf3 str\cf0 >\

\i \cf4 Calls fun with an index into the characters to be parsed until it returns zero characters.
\f1\i0\fs24 \cf0 \

\f0\i\fs28 \cf4 Increments line.
\f1\i0\fs24 \cf0 \
\

\f0\b\fs48 generic parsers\

\fs28 \cf2 fn
\b0 \cf0  
\b litv
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 s:
\i0 \cf0  \cf3 str\cf0 , 
\i \cf2 value:
\i0 \cf0  T) -> parser<T>\

\i \cf4 Returns value if input matches s
\f1\fs24 \cf0 .
\f0\i0\fs28 \

\f1\fs24 \

\f0\b\fs48 specialized parsers\

\fs28 \cf2 fn
\b0 \cf0  
\b identifier
\b0 () -> parser<\cf3 str\cf0 >\

\i \cf4 Matches [a-zA-Z_] [a-zA-Z0-9_]*.
\f1\i0\fs24 \cf0 \

\f0\fs28 \

\b \cf2 fn
\b0 \cf0  
\b integer
\b0 () -> parser<\cf3 int\cf0 >\

\i \cf4 Matches [+-]? [0-9]+.
\i0 \cf0 \

\f1\fs24 \

\f0\b\fs48 parser combinators\

\fs28 \cf2 fn
\b0 \cf0  
\b chainl1
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>, 
\i \cf2 op:
\i0 \cf0  parser<U>, 
\i \cf2 eval:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (T, U, T) -> T) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b chainr1
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>, 
\i \cf2 op:
\i0 \cf0  parser<U>, 
\i \cf2 eval:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (T, U, T) -> T) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b chain_suffix
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>, 
\i \cf2 op:
\i0 \cf0  parser<U>) -> parser<[(U, T)]>\

\b \cf2 fn
\b0 \cf0  
\b forward_ref
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  @
\b \cf2 mut
\b0 \cf0  parser<T>) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b list
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>, 
\i \cf2 sep:
\i0 \cf0  parser<U>) -> parser<[T]>\

\b \cf2 fn
\b0 \cf0  
\b optional
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>, 
\i \cf2 missing:
\i0 \cf0  T) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b or
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser1:
\i0 \cf0  parser<T>, 
\i \cf2 parser2:
\i0 \cf0  parser<T>) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b or_v
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parsers:
\i0 \cf0  [parser<T>]) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b repeat0
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>) -> parser<[T]>\

\b \cf2 fn
\b0 \cf0  
\b repeat1
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>, 
\i \cf2 err_mesg:
\i0 \cf0  \cf3 str\cf0 ) -> parser<[T]>\

\b \cf2 fn
\b0 \cf0  
\b seqN
\b0 <\cf5 T0\cf0 : 
\b \cf2 copy
\b0 \cf0 , \cf5 T1\cf0 : 
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 R:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser0:
\i0 \cf0  parser<\cf5 T0\cf0 >, 
\i \cf2 parser1:
\i0 \cf0  parser<\cf5 T1\cf0 >, 
\i \cf2 eval:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (\cf5 T0\cf0 , \cf5 T1\cf0 ) -> result::result<R, \cf3 str\cf0 >) -> parser<R>\
\pard\pardeftab480\pardirnatural

\b \cf2 fn
\b0 \cf0  
\b seqN_retM
\b0 <
\i \cf2 T0:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 T1:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 p0:
\i0 \cf0  parser<T0>, 
\i \cf2 p1:
\i0 \cf0  parser<T1>) -> parser<T0>\
\pard\pardeftab480\pardirnatural

\b \cf2 fn
\b0 \cf0  
\b s0
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b s1
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b tag
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>, 
\i \cf2 label:
\i0 \cf0  \cf3 str\cf0 ) -> parser<T>\
\

\b \cf2 fn
\b0 \cf0  
\b thene
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser:
\i0 \cf0  parser<T>, 
\i \cf2 eval:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (T) -> parser<U>) -> parser<U>\

\i \cf4 p().thene(\{|pvalue| return(2*pvalue)\})
\f1\i0\fs24 \cf0 \
\

\f0\b\fs48 misc\

\fs28 \cf2 fn
\b0 \cf0  
\b fails
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 mesg:
\i0 \cf0  \cf3 str\cf0 ) -> parser<T>\

\b \cf2 fn
\b0 \cf0  
\b return
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 value:
\i0 \cf0  T) -> parser<T>\
\

\b \cf2 impl
\b0 \cf0  
\b\fs48 str_methods
\b0\fs28  
\b \cf2 for
\b0 \cf0  \cf3 str\cf0 \
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b lit
\b0 () -> parser<\cf3 str\cf0 >\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b litv
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 value:
\i0 \cf0  T) -> parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b s0
\b0 () -> parser<\cf3 str\cf0 >\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b s1
\b0 () -> parser<\cf3 str\cf0 >\

\f1\fs24 \

\f0\b\fs28 \cf2 impl
\b0 \cf0  
\b\fs48 parse_methods
\b0\fs28 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 > 
\b \cf2 for
\b0 \cf0  parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b thene
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 eval:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (T) -> parser<U>) -> parser<U>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b then
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser2:
\i0 \cf0  parser<U>) -> parser<U>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b or
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 parser2:
\i0 \cf0  parser<T>) -> parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b optional
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 missing:
\i0 \cf0  T) -> parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b repeat0
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >() -> parser<[T]>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b repeat1
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 err_mesg:
\i0 \cf0  \cf3 str\cf0 ) -> parser<[T]>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b list
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 sep:
\i0 \cf0  parser<U>) -> parser<[T]>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b chain_suffix
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 op:
\i0 \cf0  parser<U>) -> parser<[(U, T)]>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b chainl1
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 op:
\i0 \cf0  parser<U>, 
\i \cf2 eval:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (T, U, T) -> T) -> parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b chainr1
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 , 
\i \cf2 U:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 op:
\i0 \cf0  parser<U>, 
\i \cf2 eval:
\i0 \cf0  
\b \cf2 fn
\b0 \cf0 @ (T, U, T) -> T) -> parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b tag
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 label:
\i0 \cf0  \cf3 str\cf0 ) -> parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b parse
\b0 (
\i \cf2 file:
\i0 \cf0  \cf3 str\cf0 , 
\i \cf2 text:
\i0 \cf0  \cf3 str\cf0 ) -> parse_status<T>\
\cb6 	\cb1 \
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b s0
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >() -> parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b s1
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >() -> parser<T>\
\cb6 	
\b \cf2 \cb1 fn
\b0 \cf0  
\b everything
\b0 <
\i \cf2 T:
\i0 \cf0  
\b \cf2 copy
\b0 \cf0 >(
\i \cf2 space:
\i0 \cf0  parser<T>) -> parser<T>\
}