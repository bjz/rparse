create allows directory references
functions can have preconditions
how does operator overloading work?
how do classes work?


* Would it be nicer if s was part of state?
	- look at how the parse expr code shakes out
* May want to sort the parser functions.
* Update rust lang
	- allow crust before fn
	- priv, new, self are keywords
	- args can have a space before the :
	- can have a space before < in generic functions
	- class introduces a new type
	- void void function doesn't need parens (see uv.rs 338)
* Use #[crate_type = "lib"]; in rc file instead of --lib.
 * uv module has support for handling async events.
* Might want to record usage for some key types.
* May want to mark some functions as pure. Maybe all of them?
* State needs a value:
 	- work on an expr parser
 	- will probably need eval arguments
 	- can functions return a different value type?
 	- do we want to cut back on some of the different methods?
 	
 	- work on a simplistic xml dom parser
* Would operator overloading make the syntax nicer?
* test code should probably use to_str interface instead of %?.
* Work on parser library:
	- add tests for the rest of the functions
	- add test expr
	- add test parse tree
	- be sure to check error reporting
	- might want ascii and unicode versions of relevent parsers (eg whitespace)
	- might want a few more specialized parsers (like C whitespace and ascii whitespace)
* Update the readme with an example
	- may want to switch to markdown as well
* Make needs to build debug or release.
* Think about adding support for col numbers (probably via a get_col function).
* Add an install target
	- consumers should have an update-libraries target
* Look at some existing parser libraries.
* Search for todo.
* Add to cargo?
* May want to ask for a code review on mailing list.
* Issues:
	- reference manual is way too loose




#[cfg(unimplemented)]
#[doc = "optional := e?"]
fn optional<T>(input: state, parser: parser<T>) -> status<T>
{
	ret result::err({output: input, mesg: "not implemented"});
}

#[cfg(unimplemented)]
#[doc = "repeat_zero := e*"]
fn repeat_zero<T>(input: state, parser: parser<T>) -> status<T>
{
	ret result::err({output: input, mesg: "not implemented"});
}

#[cfg(unimplemented)]
#[doc = "repeat_one := e+"]
fn repeat_one<T>(input: state, parser: parser<T>) -> status<T>
{
	ret result::err({output: input, mesg: "not implemented"});
}

#[cfg(unimplemented)]
#[doc = "list := elem (sep space elem)*"]
fn list<T>(input: state, elem: parser<T>, sep: str, space: parser<()>) -> status<[T]>
{
	ret result::err({output: input, mesg: "not implemented"});
}

------------------------------------------------------------------------------------
#[doc = "identifier := [a-zA-Z_] [a-zA-Z_0-9]* space"]
fn identifier(input: state, space: parser<()>) -> status<str>
{
	let mut ch = input.text[input.index];
	if !(is_alpha(ch) || ch == '_')
	{
		ret result::err({output: input, mesg: "expected identifier"});
	}
	
	let mut i = input.index;
	while is_alphanum(input.text[i]) || input.text[i] == '_'
	{
		i += 1u;
	}
	
	alt space({index: i with input})
	{
		result::ok(answer)
		{
			let value = vec::slice(input.text, input.index, i - input.index);
			ret result::ok({output: answer.output, value: str::from_chars(value)});
		}
		result::err(error)
		{
			ret result::err(error);
		}
	}
}
----------------------------------------------------------------

#[test]
fn test_identifier()
{
	assert check_err("", bind identifier(_, s), "expected identifier", 1);
	assert check_ok("begin end", bind identifier(_, s), "begin", 1);
	assert check_ok("beginning", bind identifier(_, s), "beginning", 1);
	assert check_ok("z99_", bind identifier(_, s), "z99_", 1);
	assert check_ok("_", bind identifier(_, s), "_", 1);
}
