* identifier_p (takes predicates)
* match_v (takes vector of predicates)
* Should be general ways to match with str result and T result
* Maybe delimited, delimited_e (for escaped) and prefixed
* Make sure that there is good support for matching lexical elements, including case-insensitive keywords and strings
* Maybe c_str, c_int, c_float (replace identifier with c_identifier)
* Cheat sheet: protypes, help, usage		str type, generic type, specialized (ie c), combinators
* Probably should review parsec3 and/or polyparse
* Update web page
* Talk about info and debug logging.

* Would be more efficient to use char_range_at instead of converting the text to [char]
	- is this true given that we want to add EOT? could rely on the embedded null char
	- getting the col might be a little icky because that requires going backwards
* Talk about the theory and limitations.
	http://blogs.msdn.com/b/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
* May want to package the exported items into rparse namespace. See #1238.
* Might want an example of parsing significant whitespace.
* Probably better to build as a static library, see #552.
* Would be nice if there was a way to localize messages:
	- maybe state could have a fn to map key strings to localized versions
* Release checklist:
	- search for TODO (in all files)
	- make sure readme example works when using rparse
	- run unit tests in release
	- run unit tests in debug
	- review README
	- use git log --oneline > CHANGE_LOG
	- update CHANGES file
	- push changes
	- upload new source package
	- review the front page of the web site
	- update cargo, see bug 2266
	- create a new branch for the release
	- update version (both in the crate and the readme)


https://github.com/jesse99/rparse
/Users/jessejones/Documents/Developer/rust.rtf

