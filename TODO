create allows directory references
functions can have preconditions
how does operator overloading work?
how do classes work?


* Update rust lang
	- allow crust before fn
	- priv, new, self are keywords
	- args can have a space before the :
	- class introduces a new type
* Use #[crate_type = "lib"]; in rc file instead of --lib.
 * Void void function doesn't need parens (see uv.rs 338)
 * uv module has support for handling async events.
* Might want to record usage for some key types.
* May want to mark some functions as pure. Maybe all of them?
* State needs a value:
 	- work on an expr parser
 	- will probably need eval arguments
 	- can functions return a different value type?
 	- do we want to cut back on some of the different methods?
 	
 	- work on a simplistic xml dom parser
* Would operator overloading make the syntax nicer?
* test code should probably use to_str interface instead of %?.
* Work on parser library:
	- add tests for the rest of the functions
	- add test expr
	- add test parse tree
	- be sure to check error reporting
	- might want ascii and unicode versions of relevent parsers (eg whitespace)
	- might want a few more specialized parsers (like C whitespace and ascii whitespace)
* Update the readme with an example
	- may want to switch to markdown as well
* Make needs to build debug or release.
* Think about adding support for col numbers (probably via a get_col function).
* Add an install target
	- consumers should have an update-libraries target
* Look at some existing parser libraries.
* Add to cargo?
* May want to ask for a code review on mailing list.
* Issues:
	- reference manual is way too loose


//#[test]
//fn test_expr()
//{
//	// Expr := Mult ('+' | '-' Mult)*
//	// Mult = Number ('*' | '/' Number)*
//	let parse_mult = bind(parse_terms, _, _, integer, ["*", "/"], [{|x, y| x*y}, {|x, y| x/y}]);
//	let parse_add = bind(parse_terms, _, _, parse_mult, ["+", "-"], [{|x, y| x+y}, {|x, y| x-y}]);
//	let parse = bind(parse_all, _, _, parse_add);
//
//	alt parse(text, index)
//	{
//		result::ok(answer)	{assert(answer.value = expected); assert(answer.index == len(answer.text))}
//		result::err(mesg)	{ret result::err(mesg)}
//	}
//	
//	check("2+3*5", 17);
//}




#[cfg(unimplemented)]
#[doc = "optional := e?"]
fn optional<T>(input: state, parser: parser<T>) -> status<T>
{
	ret result::err({output: input, mesg: "not implemented"});
}

#[cfg(unimplemented)]
#[doc = "repeat_zero := e*"]
fn repeat_zero<T>(input: state, parser: parser<T>) -> status<T>
{
	ret result::err({output: input, mesg: "not implemented"});
}

#[cfg(unimplemented)]
#[doc = "repeat_one := e+"]
fn repeat_one<T>(input: state, parser: parser<T>) -> status<T>
{
	ret result::err({output: input, mesg: "not implemented"});
}

#[cfg(unimplemented)]
#[doc = "alternative := e1 | e2 | â€¦"]
fn alternative<T>(input: state, alternatives: [parser<T>]) -> status<T>
{
	ret result::err({output: input, mesg: "not implemented"});
}

#[cfg(unimplemented)]
#[doc = "list := elem (sep space elem)*"]
fn list<T>(input: state, elem: parser<T>, sep: str, space: parser<()>) -> status<[T]>
{
	ret result::err({output: input, mesg: "not implemented"});
}

#[cfg(unimplemented)]
#[doc = "terms := term ([ops] space term)*"]
fn terms<T>(input: state, term: parser<T>, ops: [str], space: parser<()>, evaluators: [fn (T, T) -> T]) -> status<T>
{
	ret result::err({output: input, mesg: "not implemented"});
}

------------------------------------------------------------------------------------
#[doc = "literal := <literal> space"]
fn literal(input: state, literal: str, space: parser<()>) -> status<str>
{
	assert str::is_ascii(literal);		// so it's OK to cast literal to char, TODO: could relax this with an each_char that passed in both the char and its index
	
	let mut i = 0u;
	while i < str::len(literal)
	{
		if input.text[input.index + i] == literal[i] as char
		{
			i += 1u;
		}
		else
		{
			ret result::err({output: input, mesg: #fmt["expected '%s'", literal]});
		}
	}
	
	alt space({index: input.index + i with input})
	{
		result::ok(answer)
		{
			ret result::ok({output: answer.output, value: literal});
		}
		result::err(error)
		{
			ret result::err(error);
		}
	}
}

#[doc = "identifier := [a-zA-Z_] [a-zA-Z_0-9]* space"]
fn identifier(input: state, space: parser<()>) -> status<str>
{
	let mut ch = input.text[input.index];
	if !(is_alpha(ch) || ch == '_')
	{
		ret result::err({output: input, mesg: "expected identifier"});
	}
	
	let mut i = input.index;
	while is_alphanum(input.text[i]) || input.text[i] == '_'
	{
		i += 1u;
	}
	
	alt space({index: i with input})
	{
		result::ok(answer)
		{
			let value = vec::slice(input.text, input.index, i - input.index);
			ret result::ok({output: answer.output, value: str::from_chars(value)});
		}
		result::err(error)
		{
			ret result::err(error);
		}
	}
}
----------------------------------------------------------------

#[test]
fn test_literal()
{
	assert check_err("", bind literal(_, "+", s), "expected '+'", 1);
	assert check_ok("+ x", bind literal(_, "+", s), "+", 1);
	assert check_ok("<<", bind literal(_, "<<", s), "<<", 1);
}

#[test]
fn test_identifier()
{
	assert check_err("", bind identifier(_, s), "expected identifier", 1);
	assert check_ok("begin end", bind identifier(_, s), "begin", 1);
	assert check_ok("beginning", bind identifier(_, s), "beginning", 1);
	assert check_ok("z99_", bind identifier(_, s), "z99_", 1);
	assert check_ok("_", bind identifier(_, s), "_", 1);
}
